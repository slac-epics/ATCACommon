# 
# ATCACommon EPICS module
#
This module brings FPGA registers that are common to all ATCA-based IOC
applications:
    - Crossbar control.
    - Firmware information, like version and build number.
    - DaqMux configuration and waveform control.

***************************************************************
* 1) Building the IOC application with the ATCACommon module *
***************************************************************

1.1) configure/RELEASE
ATCA_COMMON_MODULE_VERSION=<module version>
CROSSBARCONTROL=$(EPICS_MODULES)/crossbarControl/$(CROSSBARCONTROL_MODULE_VERSION)
 
1.2) configure/CONFIG_SITE
# ATCA COMMON API
COMMONATCA_PACKAGE_NAME=atca/commonATCA
COMMONATCA_VERSION=<package version>
COMMONATCA_TOP=$(PACKAGE_SITE_TOP)/$(COMMONATCA_PACKAGE_NAME)/$(COMMONATCA_VERSION)
COMMONATCA_LIB=$(COMMONATCA_TOP)/$(PKG_ARCH)/lib
COMMONATCA_INCLUDE=$(COMMONATCA_TOP)/$(PKG_ARCH)/include
 
1.3) src/Makefile
USR_INCLUDES += -I$(COMMONATCA_INCLUDE)
commonATCA_DIR = $(COMMONATCA_LIB)
USR_LIBS_Linux += commonATCA
<app>_DBD += ATCACommon.dbd
<app>_LIBS += ATCACommon
 
1.4) Db/Makefile
You need do verify what type of data is being sent through the DaqMux waveforms. Pick up the right database file for your case:

# ATCA common
DB_INSTALLS += $(ATCACOMMON)/db/crossbarCtrl.db
DB_INSTALLS += $(ATCACOMMON)/db/ATCACommon.db
DB_INSTALLS += $(ATCACOMMON)/db/StreamType.db
# Uncomment for 16-bits unsigned integer in waveform
#DB_INSTALLS += $(ATCACOMMON)/db/StreamUshort.db
# Uncomment for 16-bits signed integer in waveform
#DB_INSTALLS += $(ATCACOMMON)/db/StreamShort.db
# Uncomment for 32-bits unsigned integer in waveform
#DB_INSTALLS += $(ATCACOMMON)/db/StreamUlong.db
# Uncomment for 32-bits signed integer in waveform
#DB_INSTALLS += $(ATCACOMMON)/db/StreamLong.db
# Uncomment for single precision float waveform
#DB_INSTALLS += $(ATCACOMMON)/db/StreamFloat.db
# Uncomment for double precision float waveform
#DB_INSTALLS += $(ATCACOMMON)/db/StreamDouble.db
 
1.5) st.cmd
# Don't use this before cpswLoadYamlFile()
# crossbarControlAsynDriverConfigure(Asyn port name, yaml path)
crossbarControlAsynDriverConfigure("crossbar", "mmio/AmcCarrierCore/AxiSy56040")
# Command to access common platform FPGA registers
# cpswATCACommonAsynDriverConfigure(Asyn port name, yaml path, named root (optional))
cpswATCACommonAsynDriverConfigure("atca", "mmio", "")
 
# Command to access common platform ATCA DAqMux waveforms. Use the command once per AMC card.
# cpswDebugStreamAsynDriverConfigure (Asyn port name (must be different from previous one), buffer size (samples), header_enable/header_disable, name of each of the 4 streams as defined on the yaml file)
cpswDebugStreamAsynDriverConfigure("atca_str0", 0x4000, "header_enabled", "Stream0", "Stream1", "Stream2", "Stream3")
cpswDebugStreamAsynDriverConfigure("atca_str1", 0x4000, "header_enabled", "Stream4", "Stream5", "Stream6", "Stream7")
 
# ATCA common features
dbLoadRecords("db/ATCACommon.db", "DEV=${P},PORT=atca")
dbLoadRecords("db/crossbarCtrl.db", "DEV=$(P), PORT=crossbar")
# The following databases must be called once per AMC card
dbLoadRecords("db/StreamType.db", "DEV=${P}:STR0, PORT=atca_str0")
dbLoadRecords("db/StreamType.db", "DEV=${P}:STR1, PORT=atca_str1")
# Uncomment for 16-bits unsigned integer in waveform
#dbLoadRecords("db/StreamUshort.db", "DEV=${P}:STR0, PORT=atca_str0, NELM=4096, TSE=-2")
#dbLoadRecords("db/StreamUshort.db", "DEV=${P}:STR1, PORT=atca_str1, NELM=4096, TSE=-2")
# Uncomment for 16-bits signed integer in waveform
#dbLoadRecords("db/StreamShort.db", "DEV=${P}:STR0, PORT=atca_str0, NELM=4096, TSE=-2")
#dbLoadRecords("db/StreamShort.db", "DEV=${P}:STR1, PORT=atca_str1, NELM=4096, TSE=-2")
# Uncomment for 32-bits unsigned integer in waveform
#dbLoadRecords("db/StreamUlong.db", "DEV=${P}:STR0, PORT=atca_str0, NELM=4096, TSE=-2")
#dbLoadRecords("db/StreamUlong.db", "DEV=${P}:STR1, PORT=atca_str1, NELM=4096, TSE=-2")
# Uncomment for 32-bits signed integer in waveform
#dbLoadRecords("db/StreamLong.db", "DEV=${P}:STR0, PORT=atca_str0, NELM=4096, TSE=-2")
#dbLoadRecords("db/StreamLong.db", "DEV=${P}:STR1, PORT=atca_str1, NELM=4096, TSE=-2")
# Uncomment for single precision float waveform
#dbLoadRecords("db/StreamFloat.db", "DEV=${P}:STR0, PORT=atca_str0, NELM=4096, TSE=-2")
#dbLoadRecords("db/StreamFloat.db", "DEV=${P}:STR1, PORT=atca_str1, NELM=4096, TSE=-2")
# Uncomment for double precision float waveform
#dbLoadRecords("db/StreamDouble.db", "DEV=${P}:STR0, PORT=atca_str0, NELM=4096, TSE=-2")
#dbLoadRecords("db/StreamDouble.db", "DEV=${P}:STR1, PORT=atca_str1, NELM=4096, TSE=-2")
 
**************
* 2) Screens *
**************

The module provides an EDM screen for testing but it is going to be deprecated. A PyDM version is under development and will be based on the LLRF screens. You can download these PyDM screens from here: https://github.com/cristinasewell/ATCA_PyDM_Screens/releases/tag/v1.0.1. The following explanations will be based on these screens.

Launch it through:
pydm -m "DEVICE=<record base name>, RTM=<record base name>:0, LOCA=<location description>, IOC_UNIT=<unit description>, INST=0" atcaLLRF.py &

Change <record base name>, <location description>, and <unit description> accordingly.

These screens have more PVs than what is provided by ATCACommon. What you will need is part of the main screen and the screens that come from the buttons "Timing", "JESD Diagnostics", and "DaqMux Settings Setup". You can ignore all the other buttons.

1.1) Main screen:
On the main screen the 4 infos about the FPGA (right on top) should be working.

Where it says "Down Converter" and "Up Converter", understand this as AMC0 and AMC1.

Choose the ADCs related to each stream channel (there is a combo box for the selection).

The waveforms will work once they are configure. This will be explained later.

Press the "JESD Diagnostics" button. Take a look if all fields are connected. You should not see disconnected PVs here.

1.2) Timing:
The "Timing" button lets you to configure the crossbar and check if the timing is arriving to the FPGA. From this screen you should also be allowed to configure the triggers (the trigger PVs are not part of the ATCACommon module, though).

********************************
* 3) Configuring the waveforms *
********************************

First thing, you have to tell the ATCACommon module what is the type of data arriving at the waveform. You do this with "caput <record base name>:<STR0 or STR1>:STREAM_TYPE<Chanel number> <type>. Change <record base name> according to your IOC application, use STR0 for AMC0 and STR1 for AMC1. <Chanel number> goes from 0 to 4 and <type> can be any of these strings:
unit32 -ULONG
int32  -LONG
uint16 -USHORT
int16  -SHORT
float32-FLOAT
float64-DOUBLE

The configured data type is autosaved and you will need to do this only once.

On the main screen, click on the "DatMux Settings Setup" button.

3.1) Waveform Engine Settings:

On the "Waveform Engine Settings" use the following values for Start and End addresses (this usually works with all the firmwares but you may need to check with the firmware engineer):
DaqMux0:
    CH 0:
        Start: 0x0
        End: 0x00004000
    CH 1:
        Start: 0x10000000
        End: 0x10004000
    CH 2:
        Start: 0x20000000
        End: 0x20004000
    CH 3:
        Start: 0x30000000
        End: 0x30004000
DaqMux1:
    CH 0:
        Start: 0x40000000
        End: 0x40004000
    CH 1:
        Start: 0x50000000
        End: 0x50004000
    CH 2:
        Start: 0x60000000
        End: 0x60004000
    CH 3:
        Start: 0x70000000
        End: 0x70004000

For all channels activate the 3 buttons "Enable", "DoneWhenFull", and "Auto-Readout".

All the above configuration is autosaved.

Click on the "Initialize" button for DaqMux0 and DaqMux1. This is not autosaved and you will need to press this button everytime the IOC boots, or put this on st.cmd:
dbpf $(DEV):WFENG0_INIT 1
dbpf $(DEV):WFENG1_INIT 1

3.2) DaqMux Settings:
Now in the "DaqMux Settings" tab:
    - Set "Buffer Size" to 4096. This usually works with all the firmwares. If not, check with the firmware engineer of your application.
    - Set the buttons like this: 
        - Cascaded Trigger "Disable"
        - "Auto Rearm"
        - "Trigger"
        - Packet Header "Enable"
        - Hardware Freeze "Disable"

Only the "Auto Rearm" option is not autosaved. You will need to press this button after each boot or put this on the st.cmd:
dbpf $(DEV):DAQMUX0_AUTOREARM 1
dbpf $(DEV):DAQMUX1_AUTOREARM 1

After all of this, if you have timing arriving at the FPGA and triggers properly set according to your application, you should see the trigger count increasing. If so, you should also see the waveforms updating on the main screen.

The screen allows you to check each waveform separately on a small chart or to see them on the same bigger chart.
